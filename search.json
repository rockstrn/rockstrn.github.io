[{"title":"cc++学习笔记","url":"/技术/undefined-1589165027.html","content":"\n\n# c++学习笔记\n\n### 1. new运算符\n\n```c++\nT* p1=new T;\nT* p2=new T[20];\ndelete p1;\ndelete []p2;\n```\n\n###  2. 内联函数\n\n​\t为了减少函数调用的开销，引入了内联函数机制，编译器处理对内联函数的调用语句时，是将整个函数代码插入到调用语句处，而不会产生调用函数的语句。不会产生参数入栈，返回地址入栈。\n定义时在函数定义前加上inline\n调用时和其他函数一样\n\n### 3. 函数重载\n\n​\t一个或多个函数，名字相同，然而参数类型或者个数不同，这叫函数的重载，返回值可以相同可以不同，如果只有返回值不同，这不叫重载\n\n### 4. 函数的缺省值\n​\t只允许最右边连续若干个参数缺省。\n​\t可以提高函数的可扩充性。\n\n### 5. 面向结构的程序设计，数据结构和算法。\n​\t面向对象的特点：抽象封装，继承，多态\n\n### 6. 一个类的 private: 可以被该类和友元访问\n\n​\tprotect:可以被该类的友元和继承类使用\n​\tpublic：该类成员，友元，继承，实例化使用\n\n### 7. 类成员函数可以重载，也可以参数缺省\n\n### 8. 类的构造函数，是成员函数的一种，分配好空间后的初始化，如给变量初值。\n​\t名字和类名相同，可以有参数，不能有返回值。初始化语句会调用构造函数\n​\t如果定义类中没有写构造函数，则生成默认无参数的构造函数，不做任何操作。定义了就不会生成。定义包括复制，类型转换。\n​\t对象生成时，构造函数自动调用，一旦生成，就不能在其上使用构造函数，一个类可以有多个构造函数。\n\n### 9. 构造函数的使用\n\n```c++\nclass T{\npublic:\n\tT(int a){};   //一个参数的构造函数\n\tT(int a,int c){};  //两个参数的构造函数\n\tT(){};   //无参构造函数\n};\nT t(1);\nT t(1,2);\nT array[2]={T(1,2),1}\nT*p=new T(1,2);\nT *parray[2]={new T(1)};  //这只调用了一次构造函数，定义指针不构造，不写与写NULL效果一样。\n```\n\n### 10.复制构造函数\n\n​\t它只有一个参数是同类对象的引用，或者是同类对象的常引用，只有一个，如果没有定义，则自动生成，完成复制功能。有定义则不自动生成。\n\n### 11 . 复制构造函数使用的三种情况\n\n​\t用一个对象初始化同类的另一个对象\n\n```cassandra\nT a=a1;\nT a(a1);\n```\n\n​\t如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用，如果不想调用可以将引用作为参数\n\n​\t如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。\n\n​\t对象的赋值不用复制构造函数。\n\n​\t用一个对象初始化同类的另一个对象\n\n​\t如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用，如果不想调用可以将引用作为参数\n如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。\n对象的赋值不用复制构造函数。\n\n### 12.类型转换构造函数\n\n​\t定义转换构造函数的目的是实现类型的自动转换，只有一个参数，而且不是复制构造函数的的构造函数，一般就可以看作是类型转换构造函数，当需要的时候，会自动调用转换构造函数，建立一个无名的临时对象。\n\n```c++\nT a;\na=9;  //这9被自动转换成一个临时complex对象\nT c=5;  //用类型转换构造函数初始化c，5不会生成临时对象。\n```\n\n### 13.析构函数\n\n​\t名字与类名相同，在前面加’~’，没有参数和返回值，一个类最多只能有一个析构函数。\n​\t析构函数在对象消亡时自动被调用。可以定义析构函数来在对象消亡前做善后工作，比如释放分配的空间。它不负责回收对象的存储空间。\n​\t如果定义类时没写析构函数，则编译器生成缺省析构函数。它什么都不做，定义了就不生成。\n\n### 14.析构函数使用情况\n\n​\t对象或者对象数组在生命期结束时，对象或者对象数组的每个元素的析构函数都会被调用。\n​\t使用new出来的对象，在delete后消亡。\n\n### 15. this指针\n\n​\t非静态成员函数中可以直接使用this来代表指向该函数作用的对象的指针，非静态成员函数，实际上有一个this指针作为参数。\n​\t静态成员函数中不能使用this指针，因为静态成员函数并不具体作用于某个对象，静态成员函数的真实的参数的个数，就是程序中写出的参数个数\n\n### 16.静态成员：在说明前面加了static关键字的成员\n\n​\t普通成员变量，每个对象有各自的一份，静态成员变量总共就一份，为所有对象共享。sizeof不会计算静态成员变量。\n​\t普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象\n​\t静态成员不需要通过对象就能访问。\n####  访问静态成员\n\n##### 1.  类名::成员名\n\n​\tT::PrintTotal();\n\n#####  2. 对象名.成员名\n\n#####   3. 指针->成员名\n\n#####   4. 引用.成员名\n\n​\t静态成员变量本质上是全局变量，一个对象都不存在，类的静态成员变量也存在\n​\t静态成员函数本质上是全局函数\n​\t设置静态成员是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，便于维护和理解。\n​\t必须在定义类的文件中对静态成员变量进行一次说明或者初始化，否则编译可以通过，链接不能通过。\n​\tint T::a=0;\n​\t在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。\n\n### 17. 成员对象和封闭类\n\n​\t有成员对象的类叫封闭类，有一个类的成员是其他类的对象，那么把这个成员叫成员对象。\n​\t任何生成封闭类对象的语句，都必须明确对象中的成员对象，是怎么样初始化的。这最常用的就是通过封闭类的构造函数的初始化列表。\n​\t封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。\n​\t对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与他们在成员初始化列表中出现的次序无关\n当封闭类的对象消亡时，先执行封闭类的析构函数，然后在执行成员对象地析构函数。次序和构造函数的次序相反。\n\n### 18. 函数的初始化列表\n\n​\t在构造函数里有\n\n```c++\nT::T(int r,int w):a(r),c(w){}   //这a,c是成员变量\n```\n\n\n\n### 19. 常量对象与常量函数\n\n​\t如果不希望某个对象的值被改变，则定义该对象的时候可以在前面加const关键字,可以访问public变量，使用常量成员函数\n\n```c++\nconst T obj;  //定义的时候不能传递参数，只能这样定义\n```\n\n​\t在类的成员函数说明后面加const关键字，则该成员函数为常量成员函数，常量成员函数执行期间，不应该修改其作用的对象，因此，在常量成员函数中，不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数。（静态成员函数除外）,常量对象上，可以执行常量成员函数。\n\n```c++\nvoid ss() const{} ;\n```\n\n\n​\t两个成员函数，名字和参数表都一样，一个有const，一个没有const,算重载。\n​\t常量对象调用常量函数，非常量对象调用非常量对象\n\n​\t两个成员函数，名字和参数表都一样，一个有const，一个没有const,算重载。\n常量对象调用常量函数，非常量对象调用非常量对象\n\n​\t在类的成员函数说明后面加const关键字，则该成员函数为常量成员函数，常量成员函数执行期间，不应该修改其作用的对象，因此，在常量成员函数中，不能修改成员变量的值（静态成员变量除外），也不能调用同类的非常量成员函数。（静态成员函数除外）,常量对象上，可以执行常量成员函数。\n\n```c++\nvoid ss() const{};\n```\n\n​\t两个成员函数，名字和参数表都一样，一个有const，一个没有const,算重载。\n​\t常量对象调用常量函数，非常量对象调用非常量对象\n\n### 20. 友元\n\n​\t友元分为友元函数和友元类两种\n\n####      1. 友元函数\n\n​\t一个类的友元函数可以访问该类的私有成员  //通常友元函数为全局函数也可以为其他类的成员函数，包括构造函数和析构函数。\n\n```c++\nfriend int T::ss(int a,int c);  \n```\n\n\n\n####      2. 友元类\n\n​\t如果A是B的友元类，那么A的成员函数可以访问B的私有成员；//在类B中声明friend A,在类A中要想访问B中的成员还要生成类B的对象\n​\t友元类之间的关系不能传递，不能继承。\nfriend class A\n\n### 21. 运算符重载\n\n​\t运算符重载的实质是函数重载   //将运算符重载为函数\n​\t可以重载为成员函数，也可以重载为普通函数\n​\t把含运算符的表达式转化成对运算符函数的调用\n​\t把运算符的操作数转化成运算符函数的参数\n​\t运算符被重载多次时，根据实参的类型决定调用哪个运算符函数\n​\t返回值类型 operator 运算符(形参表){}\n​\t重载为成员函数时，参数个数为运算符目数减一\n​\t重载为普通函数时，参数个数为运算符目数\n​\t如，’+’重载为普通函数 c=a+b;  //c=operator+(a,b)\n​\t‘-‘重载为成员函数 c=a-b;   //c=a.operator-(b)\n​\t对运算符进行重载时，好的风格是应该尽量保留运算符原本的特性。\n\n### 22. 赋值运算符’=’的重载\n​\t赋值运算符’=’只能重载为成员函数，以string类做例子\n​\ts1=s2;  //这个赋值运算符如果不重载会导致两个对象的指针变量指向同一个地方\n​\t运算符重载为友元函数，全局函数不能访问私有，成员函数可以解决c+5,但是不能解决5+c。\n\n### 23.流插入与流重载运算符的重载\n​\tcout是在iostream中定义的ostream类的对象,<<为流插入运算符\n​\tostream & ostream::operator<<(int n){  //原本定义的大概形式，重载之前\n​\t…//输出n的代码\n​\treturn  *this;}\n​\t如果重载为输出类对象的元素值，一般重载为友元函数。\n\n### 24.重载类型转换运算符\n​\t类型转换运算符一般定义为成员函数\n​\toperator double(){}   //不用写返回值类型\n​\t可以进行自动类型转换\n\n### 25.自增自减运算符的重载  函数声明可以只写参数类型\n​\t前置运算符返回的是引用，后置运算符返回的是对象\n\n```c++\nT&operator++();  //成员函数，前置运算符，返回值为引用\nT operator++(int );  //成员函数，后置运算符，返回值为对象\nT& operator--(T&);  //全局函数，前置运算符\nT&operator--(T&,int);  //全局函数，后置运算符\n```\n\n### 26. 运算符重载的注意事项\n\n#### 1. C++不允许定义新的运算符\n\n#### 2. 重载后的运算符应符合日常习惯\n\n#### 3. 运算符重载不能改变运算符优先级\n\n#### 4. 以下运算符不能被重载：”.”   “.*”   ”::”   “?:”   sizeof\n\n#### 5. 重载运算符() [] -> 或者赋值运算符=时，运算符重载函数必须声明为类的成员函数\n\n### 27. 继承和派生\n​\t继承：在定义一个新的类B时，如果该类与某个已有的类A相似（指的是B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类。\n​\t派生类拥有基类的全部成员函数和成员变量，不论是private , protected ,public\n​\t派生类对象中包含着基类对象，基类对象的存储位置位于派生类对象新增的成员变量之前。\n​\t在派生类的各个成员函数中，不能访问基类中的private成员\n​\tClass T :public T1{}  //派生类的写法为  类名:public 基类名\n​\t派生类可以覆盖基类的函数，还可以使用T:: ss  //T为基类名称  来调用基类方法。\n\n### 28.继承与复合\n​\t继承：“是”关系\n​\t基类A,B是基类A的派生类\n​\t逻辑上要求：一个B对象也是一个A对象\n​\t复合：“有”关系\n​\t类C中“有”成员变量k，k是类D的对象，则C和D是复合关系\n​\t一般逻辑上要求：“D对象是C对象的固有属性或组成部分”\n\n### 29. 覆盖\n​\t派生类可以定义一个和基类成员同名的成员，这叫覆盖，通常用在函数，在派生类访问这类成员时，缺省情况时访问派生类中定义的成员。要在派生类中访问由基类定义的同名成员时，要使用作用于符号\n​\t只要是同名就是覆盖，参数不同也是覆盖。\n​\t派生类函数友元能不能访问基类protect，应该可以\n\n### 30.保护成员\n​\tPrivate: 基类成员函数，基类友元函数\n​\tProtected: 基类成员函数，基类友元函数，派生类的成员函数可以访问当前对象的基类的保护成员\n\n### 31. 调用基类构造函数的两种方式\n\n​\t显式方式，在派生类的构造函数中，为基类的构造函数提供参数\n\n​\t隐式方式，在派生类的构造函数中，省略基类的构造函数时，派生类的构造函数则自动调用基类的默认构造函数\n\n### 32. 封闭派生类对象构造函数的执行顺序\n\n​\t基类构造函数，对象类构造函数，派生类构造函数\n\n### 33. 在public继承的赋值兼容规则\n```c++\nClass T{};\nClass T1:public T{};\n```\n\n​\t派生类的对象可以赋值给基类对象\n​\t派生类对象可以初始化基类引用\n​\t派生类对象的地址可以赋值给基类指针\n​\t声明派生类时，只需要列出它的直接基类\n​\t派生类沿着类的层次自动向上继承它的间接基类\n\n### 34. 虚函数\n​\t在类的定义中，前面有virtual关键字的成员函数就叫虚函数\n​\tvirtual int get();  //这virtual关键字只能出现在类的定义的函数声明中，在类中定义也要写，在类外定义时不用写。\n​\t构造函数和静态成员函数不能是虚函数，虚函数的子类与父类必须参数名字与个数完全相同\n\n### 35. 多态\n​\t派生类的指针可以赋值给基类的指针，这里的指针换成引用是一样的\n​\t通过基类指针调用基类和派生类的同名虚函数时\n​\t该指针指向基类对象，被调用的是基类虚函数\n​\t该指针指向派生类虚对象，被调用的是派生类虚函数\n​\t这就是多态\n​\t如果该指针调用的不是虚函数，基类指针调用的就是基类函数\n\n### 36. 多态的实现\n​\t每一个有虚函数的类（或有虚函数类的派生类）都有一个虚函数表，该类的任何对象中都放这虚函数表的指针。虚函数表中列出来该类的虚函数的地址。生成该类对象多出的四个字节就是用来放虚函数表的地址的\n​\t任何有虚函数的类，或者有虚函数的类的派生类在绑定时采用晚绑定，多出来的四个字节指针指向扩充类虚函数表，则调用的函数就是扩充类函数。\n​\t多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。\n\n### 37. 虚析构函数\n​\t通常用在new派生类对象，赋值给基类指针中。\n​\t通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数，但是，删除一个派生类的对象时，应该调用派生类的析构函数，然后调用基类的析构函数。\n​\t解决方法：把基类的析构函数声明为virtual\n​\t一个类如果定义了虚函数，应该将析构函数定义为虚函数，不允许以虚函数作为构造函数\n\n### 38. 纯虚函数\n​\t没有函数体的虚函数\n​\tVirtual void print()=0;  //纯虚函数\n\n### 39. 抽象类\n​\t包含纯虚函数的类叫抽象类\n​\t抽象类只能作为基类来派生新类使用，不能创建抽象类对象，抽象类的指针和引用可以指向由抽象类派生出来的类的对象\n​\t在抽象类的成员函数内可以调用纯虚函数，但是在构造函数或析构函数内部不能调用纯虚函数，因为\n​\t在构造函数和析构函数中调用虚函数不是多态：在构造函数和析构函数中调用虚函数不是多态，因为编译时即可确定调用的是哪个函数。如果本类有该函数，调用的就是本类的函数；如果本类没有，调用的就是直接基类的函数；如果基类没有，调用的就是间接基类的函数，以此类推。\n​\t如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数，它才能成为非抽象类。","tags":["技术","c++"],"categories":["技术"]},{"title":"第一篇文章","url":"/生活/undefined-1589118463.html","content":"巴拉巴贝拉\n\n## 学习 markdown 语法","tags":["搞笑","日常"],"categories":["生活"]},{"title":"Hello World","url":"/����/undefined-undefined.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]